/***********************************************************************/
/*                                                                     */
/*  FILE        :control_power.c                                             */
/*  DATE        :Mon, May 26, 2008                                     */
/*  DESCRIPTION :                                                      */
/*  CPU TYPE    :R8C/1B                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.0).     */
/*                                                                     */
/***********************************************************************/

#include "sfr_r823.h" 											// R8C/23 SFR定義ファイル
#include "StackBlock.h"

void shift_sck1();
void shift_sck2();
void shift_sck3();
void shift_rck1();
void shift_rck2();
void shift_rck3();
void shift_data1(unsigned char bit);
void shift_data2(unsigned char bit);
void shift_data3(unsigned char bit);
void send_x(unsigned char num, unsigned short data);
void send_y(unsigned char num, unsigned char data);
void recv_x(unsigned char surface, unsigned char x);
void multi_out(unsigned char surface, unsigned char x);
void switch_out(unsigned char surface, unsigned char x);
void recv_y(unsigned char surface, unsigned char y);

int shift3 = 0;


void shift_sck1(void){
	p0_1=1;
	p0_1=0;
}

void shift_sck2(void){
	p0_5=1;
	p0_5=0;
}

void shift_sck3(void){
	p1_1=1;
	p1_1=0;
}

void shift_rck1(void){
	p0_2=0;
	p0_2=1;
}

void shift_rck2(void){
	p0_6=0;
	p0_6=1;
}

void shift_rck3(void){
	p1_2=0;
	p1_2=1;
}

void shift_data1(unsigned char bit){
	if(bit) p0_0=1;
	else p0_0=0;
}	

void shift_data2(unsigned char bit){
	if(bit) p0_4=1;
	else p0_4=0;
}

void shift_data3(unsigned char bit){
	if(bit) p1_0=1;
	else p1_0=0;
}

void send_x(unsigned char num, unsigned short data){
	signed char i;
	switch(num){
		case UP:
			for(i=7;i>=0;i--){
			shift_data1((data>>i) & 1);
			shift_sck1();
			}	
			shift_rck1();
			if((data>>8) & 1) p0_3=1;
			else p0_3=0;
			break;
		case DOWN:
			for(i=7;i>=0;i--){
			shift_data2((data>>i) & 1);
			shift_sck2();
			}	
			shift_rck2();
			if((data>>8) & 1) p0_7=1;
			else p0_7=0;
			break;
		default:
			break;
	}
}

void send_y(unsigned char num, unsigned char data){
	signed char i;
	for(i=7;i>=0;i--){
	shift_data3((data>>i) & 1);
	shift_sck3();
	}	
	shift_rck3();
}

void recv_y(unsigned char surface, unsigned char y){
	if(surface == UP){
		switch(y){
			case 0:
				p1_6=0;
				p1_7=0;
				p2_0=0;
				break;
			case 1:
				p1_6=1;
				p1_7=0;
				p2_0=0;
				break;
			case 2:
				p1_6=0;
				p1_7=1;
				p2_0=0;
				break;
			case 3:
				p1_6=1;
				p1_7=1;
				p2_0=0;
				break;
			case 4:
				p1_6=0;
				p1_7=0;
				p2_0=1;
				break;
			default:
				break;
		}
	}
	else if(surface == DOWN){
		switch(y){
			case 0:
				p2_1=0;
				p2_2=0;
				p2_3=0;
				break;
			case 1:
				p2_1=1;
				p2_2=0;
				p2_3=0;
				break;
			case 2:
				p2_1=0;
				p2_2=1;
				p2_3=0;
				break;
			case 3:
				p2_1=1;
				p2_2=1;
				p2_3=0;
				break;
			case 4:
				p2_1=0;
				p2_2=0;
				p2_3=1;
				break;
		}
	}
}

void multi_out(unsigned char surface, unsigned char x){
	if(surface == UP){
		switch(x){
			case 0:
				p3_4=0;
				p3_5=0;
				p3_7=0;
				break;
			case 1:
				p3_4=1;
				p3_5=0;
				p3_7=0;
				break;
			case 2:
				p3_4=0;
				p3_5=1;
				p3_7=0;
				break;
			case 3:
				p3_4=1;
				p3_5=1;
				p3_7=0;
				break;
			case 4:
				p3_4=0;
				p3_5=0;
				p3_7=1;
				break;
			case 5:
				p3_4=1;
				p3_5=0;
				p3_7=1;
				break;
			case 6:
				p3_4=0;
				p3_5=1;
				p3_7=1;
				break;
			case 7:
				p3_4=1;
				p3_5=1;
				p3_7=1;
				break;
			default:
				break;
		}
	}else if(surface = DOWN){
		switch(x){
			case 0:
				p6_1=0;
				p6_2=0;
				p6_3=0;
				break;
			case 1:
				p6_1=1;
				p6_2=0;
				p6_3=0;
				break;
			case 2:
				p6_1=0;
				p6_2=1;
				p6_3=0;
				break;
			case 3:
				p6_1=1;
				p6_2=1;
				p6_3=0;
				break;
			case 4:
				p6_1=0;
				p6_2=0;
				p6_3=1;
				break;
			case 5:
				p6_1=1;
				p6_2=0;
				p6_3=1;
				break;
			case 6:
				p6_1=0;
				p6_2=1;
				p6_3=1;
				break;
			case 7:
				p6_1=1;
				p6_2=1;
				p6_3=1;
				break;
			default:
				break;
		}
	}
}

void switch_out(unsigned char surface, unsigned char x){
	if(surface == UP){
		switch(x){
			case 0:
				p4_3=0;
				p4_4=0;
				break;
			case 8:
				p4_3=1;
				p4_4=0;
				break;
			case 9:
				p4_3=0;
				p4_4=1;
				break;
			default:
				break;
		}
	}else if(surface == DOWN){
		switch(x){
			case 0:
				p6_4=0;
				p6_5=0;
				break;
			case 8:
				p6_4=1;
				p6_5=0;
				break;
			case 9:
				p6_4=0;
				p6_5=1;
				break;
			default:
				break;
		}	
	}else if(surface == CONTROL){
		switch(x){
			case 0:
				p2_5=0;
				p2_6=0;
				break;
			case 1:
				p2_5=1;
				p2_6=0;
				break;
			case 2:
				p2_5=0;
				p2_6=1;
				break;
			case 3:
				p2_5=1;
				p2_6=1;
				break;
		}
	}
}

void recv_x(unsigned char surface, unsigned char x){
	switch(surface){
		case UP:
			if(x < 8){
				p3_3=0;
				switch_out(UP,0);
				multi_out(UP,x);
			}else{
				p3_3=1;
				switch_out(UP,x);
			}
			break;
		case DOWN:
			if(x < 8){
				p6_0=0;
				switch_out(DOWN,0);
				multi_out(DOWN,x);
			}else{
				p6_0=1;
				switch_out(DOWN,x);
			}
			break;
		default:
			break;
	}
}