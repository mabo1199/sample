//
/***********************************************************************/
/*                                                                     */
/*  FILE        :seral.c                                               */
/*  DATE        :Thu, Apr 19, 2012                                     */
/*  DESCRIPTION :serial comunication file.                             */
/*  CPU GROUP   :15                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.13).    */
/*                                                                     */
/***********************************************************************/


#include "sfr_r823.h" 					// R8C/23 SFR定義ファイル
#include "StackBlock.h"



void	fifo_init(void);
void	set_UART0(void);				// UART初期化関数
void	UART0_tx(char);					// 1文字UART送信関数
void  	UART0_3tx(char);
void	UART0_tx_str(char *);			// 文字列UART送信関数
void	UART0_tx_data(unsigned int);	// 数値データUART送信関数
void	UART0_rx_int(void);
void	receive_work0(void);
void 	UART0_bin_data( unsigned int);
void	data_send(int,int,char *);		// PCに送るﾃﾞｰﾀ　S/N ch ﾒｯｾｰｼﾞ
char	bin2asc(char);
char 	UART0_rx(void);

unsigned int rque0_r,rque0_w,rque0_pw;
unsigned char rque0[RQUEMAX];
unsigned char data0[80];
int message_count;
int	count0;						// ｶﾚﾝﾄﾒｯｾｲｼﾞ長


void	fifo_init()
{
	rque0_r=0;
	rque0_w=0;
	rque0_pw=1;
	count0=0;
}


// UART0初期設定関数
void set_UART0(void)
{
	clk0_u0c0 	= 0;
	clk1_u0c0	= 0;				// クロックソースにｆ0を選ぶ
	smd0_u0mr   = 1;				// シリアルI/Oモード選択ビット
	smd2_u0mr   = 1;				// （調歩同期式 8ビットモードに設定）
	te_u0c1     = 1;				// 送信制御ビット（送信許可に設定）
	re_u0c1     = 1;				// 受信制御ビット（受信許可に設定）
	u0brg       = rate;  // ビットレートレジスタ(38400bpsに設定）
	ilvl0_s0ric = 0;				// UART0受信割り込み優先レベル（レベル1）<---受信割り込み使用時に設定
	ir_s0ric    = 0;				// UART0受信割り込み要求ビットクリア     <---受信割り込み使用時に設定
}

// 1文字送信関数
void  UART0_tx(char data)
{
	while(ti_u0c1 != 1);			// データ転送待ち（送信バッファ空）
	u0tb = data;					// 送信バッファにデータセット
}

void  UART0_3tx(char data)
{
	UART0_tx(data);
	UART0_tx(data);
	UART0_tx(data);			// 送信バッファにデータセット
}									//     （1文字送信の終了）

// 文字列送信関数
void UART0_tx_str(char *str)
{
     while(*str != '\0'){			// 文字が\0になるまで繰り返す
          UART0_tx(*str);			// 1文字送信
          str++;					// 次の文字に移る
     }
}

// 数値データをテキスト形式でUART0送信する関数
void UART0_tx_data( unsigned int data )
{
    unsigned char temp;				//
    char strtemp[10];				// 文字コードの格納変数を定義
    int i, k;						//
    i=0;							//
    do {							//
        temp = data % 10;			// 下位の桁から数字を抽出
        strtemp[i++] = temp + '0';	// 数字を文字コードに変換
    } while (( data /= 10 ) != 0);	// 数値の桁数までループ
    i--;							//
    for( k=i; k>=0; k-- ) {			// 上位の桁から順次
        UART0_tx( strtemp[k] );   	// 数値文字を順次送信
    }
}



// 数値データをバイナリー形式でUART0送信する関数
void UART0_bin_data( unsigned int data )
{
	unsigned char bb;
	
	bb = data>>8;   // High byte
	UART0_tx(bb);
	bb = data & 0xff;	// Low byte
	UART0_tx(bb);
}




// 1文字受信関数
char UART0_rx (void)
{
	int i;
	long li = 0;
    char data;						// 受信データ格納変数
    char err;						// エラーデータ格納変数
	while (ri_u0c1 != 1 && li<10000L){
		li++;	
	}		// 受信待ち
 	if(li > 9999L){
		return 'E';
	}
	data = u0rbl;					// 受信データの取り出し
	err = u0rbh & 0xf0;				// エラーデータの取り出し
    return data;					// 受信データの引渡し
//	}
}


// 割り込み受信関数
#pragma interrupt UART0_rx_int  (vect=18) 
void UART0_rx_int (void)
{
    char err,rc;						//     エラーデータ格納変数

	rc = u0rbl;
	if(rque0_pw != rque0_r){		// ring buffer is no full   
		rque0[rque0_w]=rc;
 		rque0_w = rque0_pw;
		rque0_pw = (rque0_pw+1)&(RQUEMAX-1);   // modify 2008.6.5
	}
	err = u0rbh & 0xf0;				//【2】エラーデータの取り出し
}



void	receive_work0()
{
	unsigned char rc0;

	while(rque0_r != rque0_w){		// データがあったら空になるまで処理を続行
		rc0 = rque0[rque0_r];
		rque0_r = (rque0_r+1)&(RQUEMAX-1);
		UART1_tx(rc0);
	UART1_tx(bin2asc(rc0>>4));
	UART1_tx(bin2asc(rc0 & 0xf));
		if(rc0 == CR){
			if(count0){      // 既にﾃﾞｰﾀあり
				data_send(0,count0,data0);
				count0=0;
			}
		}
		else if(count0 < MAXCOUNT){
			data0[count0++]=bin2asc(rc0>>4);
			data0[count0++]=bin2asc(rc0 & 0xf);
			data0[count0++]=SPACE;
		}
	}
}


char	bin2asc(char bvalue)
{
	if(9 < bvalue)
		return('A'+(bvalue-10));
	else
		return('0'+bvalue);
}

 				

void	data_send(int ch,int datanum,char *data)
{
	unsigned char * pdata;
	int i;
	
	pdata = data;
	
	if(message_count < 100){
		message_count++;
	}
	else{
		message_count=0;
	}
	UART0_tx(bin2asc(message_count/10));
	UART0_tx(bin2asc(message_count%10));
    UART0_tx(SPACE);
    UART0_tx(ch+'0');
    UART0_tx(SPACE);
    for(i=0;i<datanum;i++)
    	UART0_tx(*(pdata++));
    UART0_tx(CR);
    UART0_tx(LF);
 }


